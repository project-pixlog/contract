library;

import 'src/expect/expect.dart' as e;

export 'src/core_matchers.dart';
export 'src/custom_matcher.dart';
export 'src/description.dart';
export 'src/equals_matcher.dart';
export 'src/interfaces.dart';
export 'src/iterable_matchers.dart';
export 'src/map_matchers.dart';
export 'src/numeric_matchers.dart';
export 'src/operator_matchers.dart';
export 'src/order_matchers.dart';
export 'src/string_matchers.dart';
export 'src/type_matcher.dart';
export 'src/util.dart';

abstract class Contract {
  static bool verbose = true;
  static List<void Function(Object, StackTrace?)> _listeners = [];

  /// Set [verbose] mode true or false
  ///
  /// When set to true, a not null StackTrace will be provide for all listeners.
  static void setVerbose(bool verbose) => verbose = verbose;

  /// Add [listener] callback to be called whenever a [softClause] is broken
  static void addListener(void Function(Object, StackTrace?) listener) =>
      _listeners.add(listener);

  /// Remove [listener] from callback listeners list
  static void removeListener(void Function() listener) =>
      _listeners.remove(listener);

  static void dispose() {
    _listeners = [];
    verbose = true;
  }

  /// Assert that [actual] matches [matcher].
  ///
  /// This is the main assertion function. [reason] is optional and is typically
  /// not supplied, as a reason is generated from [matcher]; if [reason]
  /// is included it is appended to the reason generated by the matcher.
  ///
  /// [matcher] can be a value in which case it will be wrapped in an
  /// [equals] matcher.
  ///
  /// If the assertion fails [reason] is send to [listeners].
  ///
  /// Certain matchers, like [completion] and [throwsA], either match or fail
  /// asynchronously. When you use [softClause] with these matchers, it ensures that
  /// the test doesn't complete until the matcher has either matched or failed. If
  /// you want to wait for the matcher to complete before continuing the test, you
  /// can call [asyncClause] instead and `await` the result.
  static void softClause(dynamic actual, dynamic matcher, {String? reason}) {
    try {
      return e.expect(actual, matcher);
    } catch (e) {
      if (_listeners.isEmpty) rethrow;
      _notifyListeners(e);
    }
  }

  /// Assert that [actual] matches [matcher]. Throws if don't.
  ///
  /// This is the main assertion function. [reason] is optional and is typically
  /// not supplied, as a reason is generated from [matcher]; if [reason]
  /// is included it is appended to the reason generated by the matcher.
  ///
  /// [matcher] can be a value in which case it will be wrapped in an
  /// [equals] matcher.
  ///
  /// If the assertion fails [reason] is send to [listeners].
  ///
  /// Certain matchers, like [completion] and [throwsA], either match or fail
  /// asynchronously. When you use [softClause] with these matchers, it ensures that
  /// the test doesn't complete until the matcher has either matched or failed. If
  /// you want to wait for the matcher to complete before continuing the test, you
  /// can call [asyncClause] instead and `await` the result.
  static void clause(dynamic actual, dynamic matcher) {
    try {
      return e.expect(actual, matcher);
    } catch (e) {
      _notifyListeners(e);
      rethrow;
    }
  }

  /// Just like [softClause], but returns a [Future] that completes when the matcher
  /// has finished matching.
  ///
  /// For the [completes] and [completion] matchers, as well as [throwsA] and
  /// related matchers when they're matched against a [Future], the returned
  /// future completes when the matched future completes. For the [prints]
  /// matcher, it completes when the future returned by the callback completes.
  /// Otherwise, it completes immediately.
  ///
  /// If the matcher fails asynchronously, that failure is piped to the returned
  /// future where it can be handled by user code.
  static Future asyncClause(dynamic actual, dynamic matcher,
      {String? reason}) async {
    try {
      return e.expectLater(actual, matcher);
    } catch (e) {
      if (_listeners.isEmpty) rethrow;
      _notifyListeners(e);
    }
  }

  static void _notifyListeners(Object e) {
    final stackTrace = verbose ? StackTrace.current : null;
    for (var listenerCallback in _listeners) {
      listenerCallback(e, stackTrace);
    }
  }
}
